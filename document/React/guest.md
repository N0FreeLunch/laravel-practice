## guest에 대한 SPA 설정

### sanctum의 문제
- 라라벨에서 제공하는 sanctum은 인증된 유저를 대상으로 CSRF, Session 인증을 사용한 인증을 제공한다. 아이디 비밀번호등의 개인의 인증 정보를 기반으로 인증된 유저의 세션 쿠키와 CSRF를 발급 받아 API 접속을 허가한다.
- sanctum의 API의 미들웨어를 통과하기 위해서는 인증을 해야 하는데, 인증 정보 없이 접근하는 유저의 경우에는 API를 이용할 수 없다. 로그인 정보가 아니더라도 인증 키 등을 사용해서 인증을 해야 sanctum 미들웨어의 API를 사용할 수 있다.
- 기본적으로 라라벨에서 로그인을 하게 되면, 로그인 된 유저에 해당하는 세션이 새로 발급이 되고 해당 세션이 Sanctum API의 인증 세션 정보가 된다.

### sanctum의 CSRF 보호 기능
```js
axios.get('/sanctum/csrf-cookie').then(response => {
    // Login...
});
```
- `/sanctum/csrf-cookie` 경로로 통신을 하면 CSRF 토큰의 역할을 하는 XSRF-TOKEN 쿠키를 발급 받는데, 이를 통해서 CSRF 인증을 할 수 있다. 
- sanctum의 미들웨어는 api 미들웨어 그룹에 설정하며, 라라벨의 기본 CSRF 인증을 담당하는 미들웨어는 web 미들웨어 그룹에 `\App\Http\Middleware\VerifyCsrfToken::class`으로 추가 되어 있다.
- sanctum의 API 통신 대상은 api 라우터이므로 발급 받은 XSRF-TOKEN 토큰으로 CSRF 보호의 유효성을 검사하는 부분도 api 라우터의 sanctum 미들웨어 부분에 해당한다. 
- sanctum 미들웨어는 로그인 세션이 발급된 유저에게만 API를 통과하므로 CSRF 인증만 단독으로 사용할 수는 없다. 따라서 게스트에게 CSRF 보호를 제공하려는 용도로 sanctum을 사용할 수는 없다.

### 게스트 유저에 대한 sanctum
- 게스트에게 sanctum 인증을 제공할 필요가 있는가? 게스트에게 로그인을 한 것과 같은 효과를 주는 것이 타당하냐는 질문에 해당한다.
- 게스트 중에서도 일부 유저에게만 제한된 API를 제공해야 할 경우 sanctum을 사용할 수 있다. 하지만, 로그인 세션을 발급하는 것과 같은 귀찮은 작업을 동반한다.
- 또한 기존에 로그인 된 유저도 게스트 페이지를 봐야 하는데 동일한 URL에 발급된 세션이라면 게스트용으로 발급된 세션에 의해 기존의 유저의 세션 쿠기 정보가 덮어 씌워져 새로 로그인을 해야 할 수 있다.
- 쿠키는 URL별로 설정을 할 수 있고, domain/path_a, domain/path_b, domain/path_c 등에 따로 발급 할 수 있다. 게스트 용의 URL을 설정(예를 들어 domain/api/path_g)을 하고 domain/api/path_g/*의 API를 사용하는 이 baseURL에 대한 인증 세션을 별도로 관리 한다면 게스트 유저에 대해 sanctum을 쓸 수 있지만 여러 모로 번거로운 작업이 필요하다. 기업에서는 생산성이 중요하기 때문에 이런 작업을 꼭 해야할 것이 아니라면 대체할 수 있는 방법을 찾는 것이 중요하다.

### 게스트의 라우터 그룹은?
- 라라벨은 WEB 라우터 그룹과 API 라우터 그룹을 가지고 있다. `routes/web.php`와 `routes/api.php`에 해당한다. `app/Http/Kernel.php`을 보면 기본적으로 WEB 미들웨어 그룹은 여러가지 미들웨어를 거쳐야 하는 반면 API 미들웨어 그룹은 거쳐야 할 미들웨어가 얼마 없다.
- web 라우터 그룹은 CSRF 토큰을 검증하고 세션 쿠키를 확인한다. CSRF 토큰 검증을 통해 자사 웹 서비스에서 발급된 페이지에서 접근했는지 확인을 하고, 세션 쿠키를 통해서 로그인 된 유저인지 확인을 한다. API를 web 라우터 그룹에 정의를 한다면 API통신 시 CSRF 토큰을 포함해야 하고, 발급된 세션 정보를 확인하는 과정이 동반된다.
- 그런데 SPA 웹을 사용한다면 초기 페이지 로딩 시 CSRF 토큰을 발급한 후 페이지 전환에 페이지를 새로 서버로 부터 발급을 받지 않으므로 CSRF 토큰을 발급 받지 못하는 문제가 발생한다. 이런 경우 페이지를 리프레시 할 수 있도록 SPA에서 실패시의 화면을 표시하든가 별도의 라우터를 통해서 CSRF 토큰을 발급하고 이를 브라우저에 저장하고 API 통신 시 CSRF 토큰을 전송하도록 로직을 만들어주는 방법이 있다.

#### 세션을 사용해야 하는가?
- 세션은 로그인 한 유저를 식별하는 것 뿐만 아니라, 세션 쿠키를 발급하지 않고 있는 대상에게 세션 쿠키를 발급하고, 세션 쿠키가 발급되어 있고 유효기간 이내이면 서버의 세션과 비교하여 동일한 유저인지 판단하는 용도로 쓰인다.
- 동일한 유저에 대해 페이지가 전환 되었을 때 앞서 서버에서 설정된 값의 영향을 받는 작업을 계속하기 위한 용도로 세션을 사용한다.
- 설정한 정보를 브라우저의 로컬스토리지, 세션스토리지, 쿠키(저장 방법이 좀 더 까다로워 잘 사용하지는 않지만)등에 저장하는 방식을 사용할 수도 있다. 페이지 리프레시와 함께 유실되지만 SPA라면 자바스크립트의 메모리상에 저장을 할 수도 있을 것이다. 그럼에도 굳이 서버 세션을 사용하는 것은 보안상의 문제가 발생할 수 있기 때문이다. 앞의 페이지에서 설정한 값을 아무렇게나 변경을 해도 괜찮다면 브라우저에 저장을 해도 되겠지만, 앞서 설정한 값의 조작을 방지하고 싶을 때는 서버 세션을 사용하는 것이 필요하다.

#### SPA에서 CSRF 토큰
- 서버 세션을 사용하기 위해서는 API 라우터 그룹에 API를 정의하지 않고, WEB 라우터 그룹에 API를 정의해 주어야 한다. 
- 기본적으로 라라벨에서 CSRF 토큰은 페이지가 갱신될 때 새로 발급된다. SPA의 경우 모든 과정이 API를 사용하는 과정인데 모든 API 통신에서 CSRF 토큰을 새로 발급 받는 것은 시스템 부하를 고려할 때 좋은 방법은 아니다. 하지만 계속적으로 CSRF 토큰을 발급을 받아야 하므로 적당한 타이밍에 CSRF 토큰을 받도록 하는 것이 필요하다. SPA도 자체 프론트앤드에서의 라우팅을 하는데 페이지가 전환될 때, CSRF 토큰을 발급 받는 라우터를 호출하는 방법을 생각해 볼 수 있다.
- CSRF 토큰은 폼을 제출할 때 서버의 데이터를 업데이트 할 때 사용한다. 브라우저가 html의 폼을 사용해서 데이터를 제출하는 경우 페이지가 전환되기 때문에 다른 폼을 전송할 때는 새로운 CSRF 토큰이 세팅된다. 이를 통해서 CSRF 토큰이 갱신되므로 폼을 제출하기 전의 CSRF 토큰으로는 더 이상 요청을 수행할 수 없게 되어 폼이 2번 제출되는 것을 방지할 수 있고 CSRF 토큰이 발급되지 않은 웹 페이지에서 API 통신을 했을 때의 전송을 차단할 수 있다는 장점이 있다.
- 라라벨은 `csrf_token()`이라는 헬퍼함수를 제공한다. 이 헬퍼 함수를 통해서 WEB 라우터 그룹의 API를 통해서 토큰을 제공받고 이를 API 리퀘스트의 헤더에 `'X-CSRF-TOKEN'`라는 키의 값으로 담아서 보낼 수 있다.
- 그런데 기본적으로 라라벨의 WEB 라우터 그룹은 세션과 함께 동작을 하고, WEB 라우터가 리스폰스를 전달할 때 쿠키 정보로 CSRF 토큰 정보 암호화한 XSRF-TOKEN을 전송한다. WEB 미들웨어의 API를 사용하고 있다면 굳이 CSRF 토큰을 별도로 발급할 필요는 없는 것이다. 단, XSRF-TOKEN을 통해서 CSRF 인증을 받기 위해서는 리퀘스트 헤더의 `X-XSRF-TOKEN` 키에 쿠키에 저장된 XSRF-TOKEN 값을 세팅해서 보내 주어야 한다.
